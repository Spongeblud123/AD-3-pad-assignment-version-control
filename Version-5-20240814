"""This program is a simple math game designed for students to improve their basic math skills"""

import tkinter as tk
from tkinter import font as tkfont
import random
from tkinter import messagebox
import os


MAX_QUESTIONS = 50  # Maximum number of questions per level
TIME_LIMIT = 30  # Time limit for each question

class User:
    """Class to handle user-related information"""
    def __init__(self, username):
        self.username = username
        self.score = 0
    
    def reset_score(self):
        self.score = 0
    
    def increment_score(self):
        self.score += 1


class NumberRush:
    """Class to handle the main functions and widgets for the math game"""
    def __init__(self, root):
        self.root = root
        self.root.title('Number Rush')  # Set window title
        self.root.geometry('1000x700')  # Set window size

        # Define font styles
        self.title_text = tkfont.Font(family='Helvetica', size=20, weight='bold')
        self.normal_font = tkfont.Font(family='Helvetica', size=14)
        self.button_font = tkfont.Font(family='Helvetica', size=12, weight='bold')

        # Initialize game variables
        self.current_level = 1
        self.difficulty = {1: 'Easy', 2: 'Medium', 3: 'Hard', 4: 'Monkey Brain', 5: 'Albert Einstein'}
        self.time_limit = TIME_LIMIT  # Time limit for each question
        self.questions_left = MAX_QUESTIONS  # Questions remaining in the level
       

        # Initialize user
        self.user = None

        # Display the login screen
        self.login_page()

    def game_buttons(self):
        # Create widgets for the splash screen
        self.splash_frame = tk.Frame(self.root, bg='#e0f7fa')
        self.splash_label = tk.Label(self.splash_frame, text=f'Welcome {self.user.username} to Number Rush!', font=self.title_text, bg='#e0f7fa', fg='navy blue')
        self.start_button = tk.Button(self.splash_frame, text='Press Play To Begin', font=self.button_font, bg='navy blue', fg='white', command=self.start_countdown)
        self.splash_label.pack(pady=30)  # Add welcome label
        self.start_button.pack(pady=20)  # Add start button

        # Create widgets for the game screen
        self.game_frame = tk.Frame(self.root, bg='#e0f7fa')
        self.level_label = tk.Label(self.game_frame, text='Level: 1 - Difficulty: ' + self.difficulty[self.current_level], font=self.normal_font, bg='#e0f7fa', fg='navy blue')
        self.question_label = tk.Label(self.game_frame, text='', font=self.normal_font, bg='#e0f7fa', fg='navy blue')
        self.invalid_input_label = tk.Label(self.game_frame, text='', fg='red', font=self.normal_font, bg='#e0f7fa')
        self.answer_entry = tk.Entry(self.game_frame, font=self.normal_font, bg='#ffffff', fg='black')
        self.submit_button = tk.Button(self.game_frame, text='Submit/Press Enter', font=self.button_font, bg='navy blue', fg='white', command=self.submit_answer)
        self.score_label = tk.Label(self.game_frame, text=f'Score: {self.user.score}/10', font=self.normal_font, bg='#e0f7fa', fg='navy blue')
        self.timer_label = tk.Label(self.game_frame, text='Time left: ' + str(self.time_limit), font=self.normal_font, bg='#e0f7fa', fg='navy blue')
        self.continue_button = tk.Button(self.game_frame, text='Next Level', font=self.button_font, bg='#0288d1', fg='white', command=self.start_next_level_countdown)

        # Pack widgets on the game screen
        self.level_label.pack(pady=10)
        self.question_label.pack(pady=10)
        self.invalid_input_label.pack_forget()
        self.answer_entry.pack(pady=10)
        self.submit_button.pack(pady=15)
        self.score_label.pack(pady=10)
        self.timer_label.pack(pady=10)
        self.answer_entry.bind('<Return>', self.submit_answer_event)

        # Load and display image
        self.image = tk.PhotoImage(file='SpongeBob.png')
        self.image_label = tk.Label(self.game_frame, image=self.image, bg='#e0f7fa')
        self.image_label.pack(side='bottom', pady=20)

        self.splash_screen()  # Show splash screen

    def login_page(self):
        # Create widgets for the login screen
        self.login_box = tk.Frame(self.root, bg='#e0f7fa')
        self.login_title = tk.Label(self.login_box, text='Welcome, please login', font=self.title_text, bg='#e0f7fa', fg='navy blue')
        self.username_label = tk.Label(self.login_box, text='Username:', font=self.normal_font, bg='#e0f7fa', fg='navy blue')
        self.username_entry = tk.Entry(self.login_box, font=self.normal_font)
        self.password_label = tk.Label(self.login_box, text='Password:', font=self.normal_font, bg='#e0f7fa', fg='navy blue')
        self.password_entry = tk.Entry(self.login_box, show='*', font=self.normal_font)
        self.login_button = tk.Button(self.login_box, text='Login', font=self.button_font, bg='navy blue', fg='white', command=self.login)
        self.create_account_button = tk.Button(self.login_box, text='Create Account', font=self.button_font, bg='#0288d1', fg='white', command=self.create_account)

        # Pack widgets on the login screen
        self.login_title.pack(pady=20)
        self.username_label.pack(pady=5)
        self.username_entry.pack(pady=5)
        self.password_label.pack(pady=5)
        self.password_entry.pack(pady=5)
        self.login_button.pack(pady=10)
        self.create_account_button.pack(pady=10)
        self.login_box.pack(fill='both', expand=True)  # Fill and expand the login frame

    def splash_screen(self):
        # Display the splash screen
        self.splash_frame.pack(fill='both', expand=True)

    def remove_splash_screen(self):
        # Hide the splash screen
        self.splash_frame.pack_forget()

    def start_countdown(self):
        # Hide splash screen and start countdown
        self.remove_splash_screen()
        self.countdown_label = tk.Label(self.root, text='', font=('Helvetica', 60, 'bold'), bg='#e0f7fa', fg='navy blue')
        self.countdown_label.pack(fill='both', expand=True)
        self.countdown(3)  # Start countdown from 3

    def countdown(self, count):
        # Update countdown timer
        if count > 0:
            self.countdown_label.config(text=str(count))
            self.root.after(1000, self.countdown, count - 1)  # Update countdown every second
        else:
            self.countdown_label.config(text='GO!')
            self.root.after(1000, self.start_game)  # Start game after countdown

    def start_game(self):
        # Start the game
        self.countdown_label.pack_forget()
        self.game_frame.pack(fill='both', expand=True)
        self.user.reset_score()  # Reset score
        self.update_score()  # Update score display
        self.time_limit = TIME_LIMIT  # Reset time limit
        self.questions_left = MAX_QUESTIONS  # Reset questions count
        self.update_timer()  # Start timer
        self.answer_entry.config(state=tk.NORMAL)
        self.submit_button.config(state=tk.NORMAL)
        self.continue_button.pack_forget()  # Hide continue button
        self.answer_entry.bind('<Return>', self.submit_answer_event)  # Bind Enter key to submit answer
        self.question_asker()  # Ask first question
        if self.image_label:
            self.image_label.pack(side='bottom', pady=20)  # Display image if available

    def generate_question(self):
        # Generate a random question based on the current level
        if self.current_level == 1:
            x = random.randint(1, 10)
            y = random.randint(1, 10)
            operator = '+'
        elif self.current_level == 2:
            x = random.randint(10, 25)
            y = random.randint(10, 15)
            operator = random.choice(['+', '-'])
            if operator == '-' and x < y:
                x, y = y, x  # Swap x and y for subtraction
        elif self.current_level == 3:
            operator = random.choice(['+', '-', '*'])
            if operator in ['+', '-']:
                x = random.randint(20, 50)
                y = random.randint(20, 50)
                if operator == '-' and x < y:
                    x, y = y, x  # Swap x and y for subtraction
            else:
                x = random.randint(5, 15)
                y = random.randint(5, 15)
        elif self.current_level == 4:
            operator = random.choice(['+', '-', '*', '/'])
            if operator == '+' or operator == '-':
                x = random.randint(20, 75)
                y = random.randint(20, 75)
                if operator == '-' and x < y:
                    x, y = y, x  # Swap x and y for subtraction
            elif operator == '*':
                x = random.randint(10, 20)
                y = random.randint(10, 20)
            elif operator == '/':
                y = random.randint(5, 50)
                x = y * random.randint(1, 15)  # Generate division question
        elif self.current_level == 5:
            operator = random.choice(['+', '-', '*', '/'])
            if operator == '+' or operator == '-':
                x = random.randint(50, 100)
                y = random.randint(20, 100)
                if operator == '-' and x < y:
                    x, y = y, x  # Swap x and y for subtraction
            elif operator == '*':
                x = random.randint(15, 25)
                y = random.randint(15, 25)
            elif operator == '/':
                y = random.randint(20, 50)
                x = y * random.randint(5, 25)  # Generate division question

        question = str(x) + ' ' + operator + ' ' + str(y)
        if operator == '/':
            answer = x / y
        else:
            answer = eval(question)
        return question, round(answer, 2)  # Return question and answer

    def question_asker(self):
        # Display a question to the user
        if self.questions_left > 0 and self.user.score < 10:
            self.questions_left -= 1
            self.question, self.correct_answer = self.generate_question()
            self.question_label.config(text='Question: ' + self.question, fg='navy blue')
            self.invalid_input_label.pack_forget()
            self.answer_entry.delete(0, tk.END)
            self.answer_entry.focus()
            self.answer_entry.config(state=tk.NORMAL)
            self.submit_button.config(state=tk.NORMAL)
            self.answer_entry.bind('<Return>', self.submit_answer_event)
        else:
            self.check_score_and_continue()  # Check score and decide next step

    def submit_answer_event(self, event):
        # Handle Enter key press for submitting answer
        self.submit_answer()

    def submit_answer(self):
        # Handle answer submission
        user_answer = self.answer_entry.get()
        self.clear()  # Clear entry field
        self.answer_entry.config(state=tk.DISABLED)
        self.submit_button.config(state=tk.DISABLED)
        self.answer_entry.unbind('<Return>')  # Unbind Enter key
        try:
            user_answer = float(user_answer)
            if round(user_answer, 2) == self.correct_answer:
                self.user.increment_score()
                self.question_label.config(fg='green')  # Correct answer
                self.invalid_input_label.pack_forget()
            else:
                self.question_label.config(fg='red')  # Incorrect answer
                self.invalid_input_label.pack_forget()
            self.update_score()  # Update score display
        except ValueError:
            self.invalid_input_label.config(text='Invalid input! Please enter a number.')
            self.invalid_input_label.pack()
            self.answer_entry.delete(0, tk.END)
            self.answer_entry.config(state=tk.NORMAL)
            self.submit_button.config(state=tk.NORMAL)
            self.answer_entry.bind('<Return>', self.submit_answer_event)
            return
        if self.time_limit <= 0:
            self.check_score_and_continue()  # Check score if time is up
        else:
            self.root.after(500, self.question_asker)  # Ask another question after delay

    def update_score(self):
        # Update score display
        self.score_label.config(text=f'Score: {self.user.score}/10')

    def update_timer(self):
        # Update timer display
        if self.time_limit > 0:
            self.timer_label.config(text='Time left: ' + str(self.time_limit))
            self.time_limit -= 1
            self.timer = self.root.after(1000, self.update_timer)  # Update timer every second
        else:
            self.root.after_cancel(self.timer)
            self.check_score_and_continue()  # Check score when time is up

    def check_score_and_continue(self):
        # Check the score and proceed based on the result
        self.answer_entry.config(state=tk.DISABLED)
        self.submit_button.config(state=tk.DISABLED)
        self.answer_entry.unbind('<Return>')
        if self.user.score >= 10:
            if self.current_level == 5:
                self.congratulate_and_offer_restart()  # End game and offer restart
            else:
                self.congratulate_and_ask_next_level()  # Congratulate and proceed to next level
        else:
            self.level_failed()  # Handle level failure

    def start_next_level_countdown(self):
        # Proceed to the next level with countdown
        if hasattr(self, 'welcome_back_frame') and self.welcome_back_frame.winfo_ismapped():
            self.welcome_back_frame.pack_forget()
        self.current_level += 1
        if self.current_level <= 5:
            self.level_label.config(text='Level: ' + str(self.current_level) + ' - Difficulty: ' + self.difficulty[self.current_level])
            self.time_limit = 30
            self.questions_left = MAX_QUESTIONS
            self.answer_entry.config(state=tk.DISABLED)
            self.submit_button.config(state=tk.DISABLED)
            self.answer_entry.unbind('<Return>')
            if self.image_label:
                self.image_label.pack_forget()  # Hide image
            self.start_countdown()  # Start countdown for the next level
            if self.image_label:
                self.image_label.pack(side='bottom', pady=20)  # Show image again
        else:
            self.congratulate_and_offer_restart()  # End game if all levels are completed
        self.continue_button.pack_forget()  # Hide continue button

    def congratulate_and_ask_next_level(self):
        # Congratulate the player and ask to proceed to the next level
        self.question_label.config(fg='navy blue', text=f"Congratulations! You've completed Level {self.current_level}.")
        self.answer_entry.config(state=tk.DISABLED)
        self.submit_button.config(state=tk.DISABLED)
        self.root.after_cancel(self.timer)
        self.continue_button.pack(pady=20)  # Show continue button

    def congratulate_and_offer_restart(self):
        # Congratulate the player and offer to restart the game
        self.question_label.config(fg='navy blue', text="Congratulations! You've completed all levels!")
        self.answer_entry.config(state=tk.DISABLED)
        self.submit_button.config(state=tk.DISABLED)
        self.root.after_cancel(self.timer)
        self.restart_button = tk.Button(self.game_frame, text='Play Again', font=self.button_font, bg='navy blue', fg='white', command=self.restart_game)
        self.restart_button.pack(pady=20)  # Show restart button

    def level_failed(self):
        # Display failure message and offer to retry the level
        self.question_label.config(fg='red', text=f"Level {self.current_level} Failed! You needed 10 points.")
        self.answer_entry.config(state=tk.DISABLED)
        self.submit_button.config(state=tk.DISABLED)
        self.root.after_cancel(self.timer)
        self.retry_button = tk.Button(self.game_frame, text='Retry Level', font=self.button_font, bg='#F44336', fg='white', command=self.retry_countdown)
        self.retry_button.pack(pady=20)  # Show retry button

    def retry_countdown(self):
        # Start countdown for retrying the level
        self.retry_button.pack_forget()
        self.countdown_label = tk.Label(self.root, text='', font=('Helvetica', 60, 'bold'), bg='#e0f7fa', fg='navy blue')
        self.countdown_label.pack(fill='both', expand=True)
        self.countdown(3)  # Countdown for retry

    def restart_countdown(self):
        # Start countdown for restarting the game
        self.restart_button.pack_forget()
        self.countdown_label = tk.Label(self.root, text='', font=('Helvetica', 60, 'bold'), bg='#e0f7fa', fg='navy blue')
        self.countdown_label.pack(fill='both', expand=True)
        self.countdown(3)  # Countdown for restart

    def restart_game(self):
        # Restart the game
        self.current_level = 1
        self.level_label.config(text='Level: ' + str(self.current_level) + ' - Difficulty: ' + self.difficulty[self.current_level])
        self.user.reset_score()  # Reset score
        self.update_score()  # Update score display
        self.restart_countdown()  # Start countdown for restart

    def clear(self):
        # Clear the answer entry field
        self.answer_entry.delete(0, tk.END)

    def create_account(self):
        # Handle account creation
        username = self.username_entry.get().strip()
        password = self.password_entry.get().strip()
        if username and password:
            if self.username_exists(username):
                self.show_message('Username already exists. Please choose a different username.')
            else:
                with open('credentials.txt', 'a') as file:
                    file.write(f"{username}:{password}\n")  # Save username and password
                self.user = User(username)  # Create User object
                self.show_message('Account created successfully! Redirecting to welcome screen...')
                self.login_box.pack_forget()
                self.game_buttons()  # Create widgets for the game
                self.splash_screen()  # Show splash screen
        else:
            self.show_message('Please enter both a username and password.')

    def login(self):
        # Handle user login
        username = self.username_entry.get().strip()
        password = self.password_entry.get().strip()
        if self.validate_credentials(username, password):
            self.user = User(username)  # Create User object
            self.login_box.pack_forget()
            self.game_buttons()  # Create widgets for the game
            self.splash_screen()  # Show splash screen
        else:
            self.show_message('Invalid login credentials. Please try again.')

    def username_exists(self, username):
        # Check if username already exists
        if os.path.exists('credentials.txt'):
            with open('credentials.txt', 'r') as file:
                for line in file:
                    stored_username, _ = line.strip().split(':')
                    if username == stored_username:
                        return True  # Username exists
        return False  # Username does not exist

    def validate_credentials(self, username, password):
        # Validate username and password
        if os.path.exists('credentials.txt'):
            with open('credentials.txt', 'r') as file:
                for line in file:
                    stored_username, stored_password = line.strip().split(':')
                    if username == stored_username and password == stored_password:
                        return True  # Credentials are valid
        return False  # Invalid credentials

    def show_message(self, message):
        # Show a message box
        tk.messagebox.showinfo('Message', message)

def main():
    root = tk.Tk()
    game = NumberRush(root)
    root.mainloop()

if __name__ == "__main__":
    main()
